new Builder() creates build tree from ember-cli-build

builder.build() = processAddonBuildSteps('preBuild')
  > broccoli-builder.build()
  > processAddonBuildSteps('postBuild')
  > processAddonBuildSteps('outputReady')
  > stopAndReport('build') // on error or success
  > // if error processAddonBuildSteps('buildError') |
  > config cache clear


'ember-cli/lib/broccoli/ember-app' -> does most magic:

const p = require('ember-cli-preprocess-registry/preprocessors');
const Project = require('../models/project');
const ModuleNormalizer = require('broccoli-module-normalizer');
const AmdFunnel = require('broccoli-amd-funnel');
const ConfigReplace = require('broccoli-config-replace');
const emberAppUtils = require('../utilities/ember-app-utils'); !!!
const addonProcessTree = require('../utilities/addon-process-tree');
const processModulesOnly = require('./babel-process-modules-only');
const DefaultPackager = require('./default-packager');

check semver package

Process:
  > get config path
  > sets up preprocessors
  > sets tests and hinting
  > _initOptions -> sets directory structure ?!?!? (yes with all tracking files)
  > _initVendorFiles
  > initializeAddons() -> runs addons
  > addons get app reference
  > _importAddonTransforms
  > _notifyAddonIncluded -> addon blacklist/whitelist
  > also needs loader.js

it specifically listens to /vendor, /public, /src, /app, /tests, /src/ui/styles, app/templates

Does: babel, eslint, minifyCSS, minifyJS, sourcemaps(in production)
this.name = appName

check require('amd-name-resolver').moduleResolve


TODO: check ember-cli-babel for module transformation!

developmentEmber = ember.debug;
production = prod builder
ember testing = paths.testing // from ember-source
paths.shims(!!!!) + jquery

this.vendorFiles = omitBy(merge({
  'jquery.js': jquery,
  'handlebars.js': handlebarsVendorFiles, // none in new ember
  'ember.js': {
    development: developmentEmber,
    production: productionEmber,
  },
  'ember-testing.js': [
    emberTesting,
    { type: 'test' },
  ],
  'app-shims.js': emberShims,
  'ember-resolver.js': [
    `${this.bowerDirectory}/ember-resolver/dist/modules/ember-resolver.js`, { TODO: bowerDirectory here is vendor + node_modules + bower_components
      exports: {
        'ember/resolver': ['default'],
      },
    },
  ],
}, this.options.vendorFiles), isNull);


_customTransformsMap -> does transformation



@glimmer/opcode-compiler 2k LOC
@glimmer/runtime 7.5k LOC
@glimmer/utils Data Structures
@glimmer/vm base, @glimmer/wire-format send in wire
investigate enifed vs require
backburner(requires exports + ember-babel) 1k LOC => runloop
Ember container design, uses resolver to lookup! 1k LOC => container lookup
dag-map 200 lines
definition of application + applicationInstance (1-2k LOC)
BootOptions
Engines, containers, registry lookups, resolver (1k LOC)
Type validation on container, logger, deprecation, error, features(namespace for enabling features)
Template Helpers, Component -> they are inside ember-glimmer!! module
default components (link-to particularly interesting), default helpers; each, each-in
Curly component manager + other component default logic (2k LOC)
hash lookups each components runloop integration to handlebars, actions
mounting engines, render
ember/object and actual runloop implementations
computed properties, instrumentation, polyfills, utils
mixins, controller, router
utils comparisons, computed macros
Ember array, string
template compiler + glimmer hacks
rsvp, handlebars, route-recognizer

runloop is metal getters are runtime
bind to DOM or SimpleDOM

import Application from '@ember/application';
import GlobalsResolver from '@ember/application/globals-resolver';

let App = Application.create({
  rootElement: '#ember-app',
  LOG_TRANSITIONS: true, // basic logging of successful transitions
  LOG_TRANSITIONS_INTERNAL: true // detailed logging of all routing steps
  customEvents: {
    // prevent listeners for mouseenter/mouseleave events
    mouseenter: null,
    mouseleave: null,
    // add support for the paste event
    paste: 'paste'
  },
  Resolver: GlobalsResolver.extend({
    resolveTemplate(parsedName) {
      let resolvedTemplate = this._super(parsedName);
      if (resolvedTemplate) { return resolvedTemplate; }

      return Ember.TEMPLATES['not_found'];
    }
  })
});


Ember.Application is Ember.Engine extension

DAGMaps used for initializers

Ember.Engine use initializers when EngineInstance.buildInstance(). Each engine manages a registry that's used for dependency injection and
    exposed through `RegistryProxy`. Engines can spawn `EngineInstance` instances via `buildInstance()`.


Instance initializer = more access. Because instance initializers run after the app is fully set up. We have access to the store, container, and other items.


container -> container.Registry -> registryInjections.

Some examples of how names are resolved:

```text
'template:post'           //=> Ember.TEMPLATES['post']
'template:posts/byline'   //=> Ember.TEMPLATES['posts/byline']
'template:posts.byline'   //=> Ember.TEMPLATES['posts/byline']
'template:blogPost'       //=> Ember.TEMPLATES['blog-post']
'controller:post'         //=> App.PostController
'controller:posts.index'  //=> App.PostsIndexController
'controller:blog/post'    //=> Blog.PostController
'controller:basic'        //=> Controller
'route:post'              //=> App.PostRoute
'route:posts.index'       //=> App.PostsIndexRoute
'route:blog/post'         //=> Blog.PostRoute
'route:basic'             //=> Route
'foo:post'                //=> App.PostFoo
'model:post'              //=> App.Post
```

check Ember.environment variable

DataAdapter =complex shit

enifed('ember-glimmer' = very important binding hbs <--> JavaScript

```app/components/person-profile.js
  import Component from '@ember/component';
  import layout from '../templates/components/person-profile';

  export default Component.extend({
    layout
  });
```

Touch events:

* `touchStart`
* `touchMove`
* `touchEnd`
* `touchCancel`

Keyboard events:

* `keyDown`
* `keyUp`
* `keyPress`

Mouse events:

* `mouseDown`
* `mouseUp`
* `contextMenu`
* `click`
* `doubleClick`
* `mouseMove`
* `focusIn`
* `focusOut`
* `mouseEnter`
* `mouseLeave`

Form events:

* `submit`
* `change`
* `focusIn`
* `focusOut`
* `input`

HTML5 drag and drop events:

* `dragStart`
* `drag`
* `dragEnter`
* `dragLeave`
* `dragOver`
* `dragEnd`
* `drop`

import { htmlSafe } from '@ember/string';

htmlSafe('<div>someString</div>');

import { htmlSafe, isHTMLSafe } from '@ember/string';

without runloop there would be no components** two way data binding?


22.8k ember metal, trySet, getWithDefault, volatile, metaForProperty, getProperties, setProperties

Note that mixins extend a constructor's prototype so arrays and object literals
    defined as properties will be shared amongst objects that implement the mixin.
    If you want to define a property in a mixin that is not shared, you can define
    it either as a computed property or have it be created on initialization of the object.

router loading error substates?

import Route from '@ember/routing/route';
 export default Route.extend({
  actions: {
    loading(transition, route) {
      let controller = this.controllerFor('foo');
      controller.set('currentlyLoading', true);
       transition.finally(function() {
        controller.set('currentlyLoading', false);
      });
    }
  }
});


import { reject } from 'rsvp';
  import Route from '@ember/routing/route';
   export default Route.extend({
    beforeModel() {
      return reject('bad things!');
    },
     actions: {
      error(error, transition) {
        // Assuming we got here due to the error in `beforeModel`,
        // we can expect that error === "bad things!",
        // but a promise model rejecting would also
        // call this hook, as would any errors encountered
        // in `afterModel`.
         // The `error` hook is also provided the failed
        // `transition`, which can be stored and later
        // `.retry()`d if desired.
         this.transitionTo('login');
      }
    }
  });


debug also has testing
